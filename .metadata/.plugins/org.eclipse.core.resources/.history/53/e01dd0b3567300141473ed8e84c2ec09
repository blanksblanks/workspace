import java.util.LinkedList;
import java.util.Queue;
import java.util.Hashtable;
//import javax.swing.*;
//import java.awt.*;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;


//import java.awt.geom.Line2D;
//import javax.swing.JPanel;
import javax.swing.JComponent;

import java.util.Random;

@SuppressWarnings("serial")
public class HuffmanTree extends JComponent {
	
	private HuffmanNode root;
	private Hashtable<String, String> hash;
	final int NODE_WIDTH = 20;
	
	public HuffmanTree(HuffmanNode[] array) throws UnderflowException {
		BinaryHeap<HuffmanNode> heap = new BinaryHeap<HuffmanNode>(array);
		buildHuffmanTree(heap);
		String binaryCode = ""; // After tree is built, build binary codes for leaves
		encodeLeaves(root, binaryCode);
		int levels = root.getHeight(root) + 1;
		int frameHeight = (4 * (levels) + 3) * NODE_WIDTH; // + 3 for padding
		int frameWidth = 1; // 2^(N+1) + 1
		for (int power = 1; power <= levels; power++)
			frameWidth *= 2;
		frameWidth = (frameWidth + 1) * NODE_WIDTH; // + 1 for padding
		setPreferredSize(new Dimension(frameWidth,frameHeight));
	}
	
	private void buildHuffmanTree(BinaryHeap<HuffmanNode> heap) throws UnderflowException {
		hash = new Hashtable<String, String>();
		int num = 1; // initialize at T1
		while (heap.getCurrentSize() > 1) { // merge two smallest trees
			HuffmanNode right = heap.deleteMin();
			HuffmanNode left = heap.deleteMin();
			HuffmanNode t = new HuffmanNode(num++, right, left);
			int h = Math.max(t.getHeight(t.left), t.getHeight(t.right)) + 1;
			t.setHeight(h);
			t.fixHeight();
			System.out.println("Inserted " + t.toString() + " with kids " + left.toString() + " and " + right.toString() + " at height" + t.getHeight(t) + " and " + t.getHeight(t.left) + " and " + t.getHeight(t.right));
			heap.insert(t); // throw it back in the heap
			root = t; // last node is the root of the tree
		}
	}
	
	// TODO: edge cases: what happens if t is null or only o ne letter in the tree?
	private String encodeLeaves(HuffmanNode t, String digits) {
		if (t.isLeaf()) {
			t.setBinaryCode(digits);
			hash.put(t.getCharacter(), t.getBinaryCode());
		} else {
			encodeLeaves(t.left, digits + "0");
			encodeLeaves(t.right, digits + "1");
		}
		return digits;
	}
	
	public String decode(String binary){
		String text = "";
		String error = "This is not a valid binary encoding.";
		try {
			int i = 0;
			while (i < binary.length()) {
				HuffmanNode t = root;
				while (!t.isLeaf()) {
					t = (binary.charAt(i) == '0') ? t.left : t.right;
					i++;
				}
				text += t.getCharacter();
			}
			return text;
		} catch (IndexOutOfBoundsException e) {
			return error;
		} catch (NullPointerException n) {
			return error;
		}
	}
	
	public String encode(String s){
		String binary = "";
		for (int i = 0; i < s.length(); i++){
			String character = Character.toString(s.charAt(i));
			String code = hash.get(character);
			if (code == null)
				return (character + " is not in the Huffman tree.");
			else
				binary += code;		
		}
		return binary;
	}

	public void paintComponent(Graphics g) {

		// Use a cast to recover the Graphics2D object from the Graphics param
		Graphics2D g2 = (Graphics2D) g;

		int x = 5;
		int y = 10;
		int d = 20;

		g2.setColor(Color.BLACK);
		g2.drawLine(15, 20, 45, 20);

		Ellipse2D.Double circle = new Ellipse2D.Double(x, y, d, d);
		Color mint = new Color(162, 255, 204);
		Color random = mixRandomColorWith(mint); // white is color to be mixed
													// with
		g2.setColor(random);
		g2.fill(circle);
		g2.draw(circle);

		x += 30;

		Ellipse2D.Double circle2 = new Ellipse2D.Double(x, y, d, d);
		random = mixRandomColorWith(mint); // white is color to be mixed with
		g2.setColor(random);
		g2.fill(circle2);
		g2.draw(circle2);
	}

	public Color mixRandomColorWith(Color mix) {
		Random random = new Random();
		int red = random.nextInt(256);
		int green = random.nextInt(256);
		int blue = random.nextInt(256);

		// mix the color
		if (mix != null) {
			red = (red + mix.getRed()) / 2;
			green = (green + mix.getGreen()) / 2;
			blue = (blue + mix.getBlue()) / 2;
		}

		Color color = new Color(red, green, blue);
		return color;
	}
//
//	public void dfs() {
//		// DFS uses Stack data structure
//		MyStack stack = new MyStack();
//		stack.push(this.rootNode);
//		rootNode.visited=true;
//		printNode(rootNode);
//		while(!stack.isEmpty()) {
//			HuffmanNode node = (Node)s.peek();
//			Node child = getUnvisitedChildNode(n);
//			if(child != null) {
//				child.visited = true;
//				printNode(child);
//				s.push(child);
//			}
//			else {
//				s.pop();
//			}
//		}
//		// Clear visited property of nodes
//		clearNodes();
//	}
//}
	
	public void printTree(){
		this.printTree(root);
	}
	
    private void printTree(HuffmanNode t) {
        double nodes = 0.0;
        double level = 0.0;

        Queue<HuffmanNode> q = new LinkedList<HuffmanNode>();
        q.add(t);
        
//        System.out.println("Added " + t.getCharacter() + " to queue");
        while (!q.isEmpty()) {
            HuffmanNode node = q.poll();
//            	System.out.println("Removed " + node.getCharacter() + " from queue");

            if (node.left != null && node.right != null) {
//            	nodes += 2;
            	q.add(node.left);
            	q.add(node.right);
            	System.out.print("/\\");
//            	System.out.println("Added " + node.left.getCharacter() + " and " + node.right.getCharacter() + " to queue");
            } 
            //else if (node.isLeaf())
            	//level--;
            
            
//            else if (node.left != null && node.right == null) { // draw /
////                nodes++;
//                q.add(node.left);
////            	HuffmanNode blankr = new HuffmanNode("blankr");
////                q.add(blankr);
//            	System.out.print("/");
////            	System.out.println("Added " + node.left.getCharacter() + " and blank to queue");
//            } else if (node.left == null && node.right != null) { // draw \
////            	nodes++;
////            	HuffmanNode blankl = new HuffmanNode("blankl");
////            	q.add(blankl);
//            	q.add(node.right);
//            	System.out.print("\\");
////            	System.out.println("Added blank and " + node.right.getCharacter() + " to queue");
//            } else { // (node.left == null && node.right == null)
////            	 nodes += (Math.pow(2.0, level) - nodes);
//            	//System.out.println("Reached leaf. do nothing");
//            }
            
            System.out.print(node.toString() + "\t");
            nodes++; // node
//          System.out.println(Math.pow(2.0, level) + " compared to number of nodes " + nodes);
          if (Math.pow(2.0, level) == nodes) {
              level += 1.0;
              nodes = 0;
              System.out.println("\n");
//              System.out.println("increased level by 1");
          } 
//          else { 
//              nodes += (Math.pow(2.0, level) - nodes);
////          	System.out.println("increased nodes by 1");
//          }
          
/*

/\
 t5
/\/\
t4 t3
/\
t2 e a s
   /\
sp t1
  t nl

 */
        
        }
    }
}
