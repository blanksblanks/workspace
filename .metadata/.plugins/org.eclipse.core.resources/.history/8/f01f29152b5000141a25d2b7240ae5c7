/**
 * 
 * Exercise 3_24
 * 
 * @author nb2406
 * 
 *         Instructions: Write routines to implement two stacks using only one
 *         array. Your stack routines should not declare an overflow unless
 *         every slot in the array is used.
 * 
 *         Clarifications: We are essentially looking for a TwoStack class with
 *         standard stack methods.
 * 
 *         Again, aim for Java, but not necessarily Java that will fully
 *         compile.
 * 
 *         You need to at least implement push, pop, peek, and isEmpty methods.
 * 
 *         Public Operations: void pushTop(x) void pushBottom(x) void popTop()
 *         void popBottom() Object peekTop() Object peekBottom() bool isEmpty()
 * 
 * 
 * 
 */

public class TwoStack {

	// Left is top, right is bottom
	private Object[] stackArray;
	private int topOfStack;
	private int bottomOfStack;
	static final int DEFAULT_CAPACITY = 10;

	// constructor
	public TwoStack() {
		this.stackArray = new Object[DEFAULT_CAPACITY];
	}

	// constructor with capacity
	public TwoStack(int capacity) {
		this.stackArray = new Object[capacity];
		this.topOfStack = -1;
		this.bottomOfStack = stackArray.length;
	}

	public boolean isEmptyFromTop() {
		return (topOfStack == -1);
	}
	
	public Object peekTop() {
		if (isEmptyFromTop()) {
			throw new UnderflowException();
		} else {
			return stackArray[topOfStack];
		}
	}

	public void popTop() {
		if (isEmptyFromTop()) {
			throw new UnderflowException();
		} else {
			stackArray[topOfStack--] = null;
		}
	}
	
	public void pushTop(Object x) {
		if (isFullFromTop())
			throw new IndexOutOfBoundsException("Burp. The stack is full.");
		else {
			stackArray[topOfStack + 1] = x;
			topOfStack++;
		}
	}
	
	public boolean isEmptyFromBottom() {
		return (bottomOfStack == stackArray.length);
	}
	
	public Object peekBottom() {
		if (isEmptyFromBottom()) {
			throw new UnderflowException();
		} else {
			return stackArray[bottomOfStack];
		}
	}

	public void popBottom() {
		if (isEmptyFromBottom()) {
			throw new UnderflowException();
		} else {
			stackArray[bottomOfStack++] = null;
		}
	}
	
	public void pushBottom(Object x) {
//		if (isFullFromBottom()) {
//			throw new IndexOutOfBoundsException("Burp. The stack is full.");
			// Tested this - if we don't check isFull, it'll throw an
			// uncaught exception under the same conditions anyway
//		} else {
			stackArray[bottomOfStack - 1] = x;
			bottomOfStack--;
//		}
	}

	public boolean isFull() {
		return (topOfStack >= bottomOfStack);
	}
	
	public boolean isFullFromTop() {
		return (topOfStack == stackArray.length - 1);
	}
	
	public boolean isFullFromBottom() {
		return (bottomOfStack == 0);
	}
	
	public static void main (String[] args)
	{
		int n = 3;
		TwoStack myStack = new TwoStack(n);
		System.out.println("Just made a stack with capacity of " + n);
		myStack.pushTop("First push to top");
		System.out.println("Peek top: " + myStack.peekTop());
		myStack.pushTop("Second push to top");
		System.out.println("Peek top: " + myStack.peekTop());
		myStack.pushTop("Third push to top");
		System.out.println("Peek top: " + myStack.peekTop());
	    myStack.pushBottom("First push to bottom");
	    System.out.println("Peek top: " + myStack.peekBottom());
	    System.out.println("About to pop and peek the bottom. Ok, decided not to peek this time, because I tried and it caused an underflow exception - as expected.");
	    myStack.popBottom();
	    //	    System.out.println(myStack.peekBottom()); 
	    System.out.println("Peek top again: " + myStack.peekTop());
	    myStack.pushBottom("Second push to bottom after it's been popped");
	    System.out.println("Peek bottom: " + myStack.peekBottom());
	    myStack.pushBottom("Third push to bottom");
	    System.out.println("Peek bottom: " + myStack.peekBottom());
	    System.out.println("Now the stack is full, 3 pushes to top, 3 pushes to bottom (-1 pop bottom) = 5. I predict another push will make the stack explode.");
	    myStack.pushBottom("Fourth push to bottom");
	    System.out.println("Peek bottom: " + myStack.peekBottom());

	}
}
