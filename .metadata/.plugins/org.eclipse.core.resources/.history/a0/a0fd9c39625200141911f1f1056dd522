import java.util.Scanner;
import java.util.NoSuchElementException;

public class ExpressionTrees {
	
	private MyStack<TreeNode> tree;
	private TreeNode root;
	
	private static class TreeNode {
		private Object element;
		private TreeNode left;
		private TreeNode right;
		
		private TreeNode(String in) {
			element = in;
		}
		
		private TreeNode(String in, TreeNode left, TreeNode right) {
			element = in;
			this.left = left;
			this.right = right;
		}		
	}
	
	// public constructor calls private constructor method
	public ExpressionTrees(String[] s) {
		tree = buildTree(s);
		root = tree.peek();
	}
	
	public static boolean isOperator(String s) {
		return (s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/"));
	}
	
	private static MyStack<TreeNode> buildTree(String[] s) {
		MyStack<TreeNode> tree = new MyStack<>();
		try {
			for (int i = 0; i < s.length; i++) {
				String element = s[i];
				if (isOperator(element)) {
					tree.push(new TreeNode(element));
				} else {
					TreeNode second = tree.peekAndPop();
					TreeNode first = tree.peekAndPop();
					// push operator onto stack with links to previous 2 nodes
					TreeNode newRoot = new TreeNode(in.charAt(i), first, second);
					tree.push(newRoot);
				}
			}
			if (tree.size() > 1) {
				System.err.println("Too many operands. Please try again.");
				System.exit(1);
			}
		} catch (NoSuchElementException e) {
			System.err.println("Too few operands. Please try again.");
			System.exit(1);
		}
		return tree;
	}
	
	// public method for printing prefix expression
	public static void printPrefix(ExpressionTrees tree) {
		System.out.print("Prefix expression: ");
		printPrefix(tree.root);
		System.out.println();
	}
	
	//public method for printing infix expression
	public static void printInfix(ExpressionTrees tree) {
		System.out.print("Infix expression: " );
		printInfix(tree.root);
		System.out.println();
	}
	
	// internal method for printing prefix expression
	private static void printPrefix(TreeNode node) {
		while (node != null) {
			System.out.print(node.element + " ");
			printPrefix(node.left);
			node = node.right;
		}
	}
	
	// internal method for printing infix expression
	private static void printInfix(TreeNode node) {
		if (node.left != null) {
			System.out.print("( ");
			printInfix(node.left);
		}
		System.out.print(node.element + " ");
		if (node.right != null) {
			printInfix(node.right);
			System.out.print(") ");
		}
	}
	
	public static void evaluate(String in) {
		MyStack<Integer> evalStack = new MyStack<>();
		for (int i = 0; i < in.length(); ++i) {
			if (Character.isDigit(in.charAt(i))) { 
				evalStack.push(Character.getNumericValue(in.charAt(i)));
			} else {
				int second = evalStack.peekAndPop();
				int first = evalStack.peekAndPop();
				char operator = in.charAt(i);
				int result = 0;
				
				switch (operator) {
				case '+':
					result = first + second;
					evalStack.push(result);
					break;
				case '-':
					result = first - second;
					evalStack.push(result);
					break;
				case '*':
					result = first * second;
					evalStack.push(result);
					break;
				case '/':
					result = first / second;
					evalStack.push(result);
					break;
				default:
					System.err.println("Invalid expression. Please try again.");
					System.exit(1);
				}
			}
		}
		System.out.println("The expression evaluates to " + evalStack.peek() +".");
	}
	
	public static void main(String[] args) {
		System.out.println("Please enter a postfix expression with no spaces.");
		Scanner readin = new Scanner(System.in);
		String postfix = readin.nextLine();
		readin.close();
		
		postfix = postfix.replaceAll("\\s", ""); // remove spaces
		postfix = postfix.replaceAll("[^\\d/*+-]", ""); // remove any illegal characters
		String[] postfixArray = s.split("(?!^)"); // converts string into array
		
		ExpressionTrees tree = new ExpressionTrees(postfixArray);
		printPrefix(tree);
		printInfix(tree);
		evaluate(postfix);
	}
}

